/**
 * net
 * ===
 *
 * The net module provides you with an asynchronous network wrapper. It
 * contains methods for creating both servers and clients (called streams).
 * You can include this module with require('chrome-net')
 */

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var ipaddr = require('ipaddr.js')
var is = require('core-util-is')
var stream = require('stream')

// Track open servers and sockets to route incoming sockets (via onAccept and onReceive)
// to the right handlers.
var servers = {}
var sockets = {}

if (typeof chrome !== 'undefined') {
  chrome.sockets.tcpServer.onAccept.addListener(onAccept)
  chrome.sockets.tcpServer.onAcceptError.addListener(onAcceptError)
  chrome.sockets.tcp.onReceive.addListener(onReceive)
  chrome.sockets.tcp.onReceiveError.addListener(onReceiveError)
}

function onAccept (info) {
  if (info.socketId in servers) {
    servers[info.socketId]._onAccept(info.clientSocketId)
  } else {
    console.error('Unknown server socket id: ' + info.socketId)
  }
}

function onAcceptError (info) {
  if (info.socketId in servers) {
    servers[info.socketId]._onAcceptError(info.resultCode)
  } else {
    console.error('Unknown server socket id: ' + info.socketId)
  }
}

function onReceive (info) {
  if (info.socketId in sockets) {
    sockets[info.socketId]._onReceive(info.data)
  } else {
    console.error('Unknown socket id: ' + info.socketId)
  }
}

function onReceiveError (info) {
  if (info.socketId in sockets) {
    sockets[info.socketId]._onReceiveError(info.resultCode)
  } else {
    console.error('Unknown socket id: ' + info.socketId)
  }
}

/**
 * Creates a new TCP server. The connectionListener argument is automatically
 * set as a listener for the 'connection' event.
 *
 * @param  {Object} options
 * @param  {function} listener
 * @return {Server}
 */
exports.createServer = function (options, listener) {
  return new Server(arguments[0], arguments[1])
}

/**
 * net.connect(options, [connectionListener])
 * net.createConnection(options, [connectionListener])
 *
 * Constructs a new socket object and opens the socket to the given location.
 * When the socket is established, the 'connect' event will be emitted.
 *
 * For TCP sockets, options argument should be an object which specifies:
 *
 *   port: Port the client should connect to (Required).
 *   host: Host the client should connect to. Defaults to 'localhost'.
 *   localAddress: Local interface to bind to for network connections.
 *
 * ===============================================================
 *
 * net.connect(port, [host], [connectListener])
 * net.createConnection(port, [host], [connectListener])
 *
 * Creates a TCP connection to port on host. If host is omitted,
 * 'localhost' will be assumed. The connectListener parameter will be
 * added as an listener for the 'connect' event.
 *
 * @param {Object} options
 * @param {function} listener
 * @return {Socket}
 */
exports.connect = exports.createConnection = function () {
  var args = normalizeConnectArgs(arguments)
  var s = new Socket(args[0])
  return Socket.prototype.connect.apply(s, args)
}

inherits(Server, EventEmitter)

/**
 * Class: net.Server
 * =================
 *
 * This class is used to create a TCP server.
 *
 * Event: 'listening'
 *   Emitted when the server has been bound after calling server.listen.
 *
 * Event: 'connection'
 *   - Socket object The connection object
 *   Emitted when a new connection is made. socket is an instance of net.Socket.
 *
 * Event: 'close'
 *   Emitted when the server closes. Note that if connections exist, this event
 *   is not emitted until all connections are ended.
 *
 * Event: 'error'
 *   - Error Object
 *   Emitted when an error occurs. The 'close' event will be called directly
 *   following this event. See example in discussion of server.listen.
 */
function Server (/* [options], listener */) {
  var self = this
  if (!(self instanceof Server)) return new Server(arguments[0], arguments[1])
  EventEmitter.call(self)

  var options

  if (is.isFunction(arguments[0])) {
    options = {}
    self.on('connection', arguments[0])
  } else {
    options = arguments[0] || {}

    if (is.isFunction(arguments[1])) {
      self.on('connection', arguments[1])
    }
  }

  self._destroyed = false
  self._connections = 0
}
exports.Server = Server

/**
 * server.listen(port, [host], [backlog], [callback])
 *
 * Begin accepting connections on the specified port and host. If the host is
 * omitted, the server will accept connections directed to any IPv4 address
 * (INADDR_ANY). A port value of zero will assign a random port.
 *
 * Backlog is the maximum length of the queue of pending connections. The
 * actual length will be determined by your OS through sysctl settings such as
 * tcp_max_syn_backlog and somaxconn on linux. The default value of this
 * parameter is 511 (not 512).
 *
 * This function is asynchronous. When the server has been bound, 'listening'
 * event will be emitted. The last parameter callback will be added as an
 * listener for the 'listening' event.
 *
 * @return {Socket}
 */
Server.prototype.listen = function (/* variable arguments... */) {
  var self = this

  var lastArg = arguments[arguments.length - 1]
  if (is.isFunction(lastArg)) {
    self.once('listening', lastArg)
  }

  // If port is invalid or undefined, bind to a random port.
  var port = toNumber(arguments[0]) || 0

  var address
  if (arguments[1] == null ||
      is.isFunction(arguments[1]) ||
      is.isNumber(arguments[1])) {
    // The first argument is the port, no IP given.
    address = '0.0.0.0'
  } else {
    address = arguments[1]
  }

  // The third optional argument is the backlog size.
  // When the ip is omitted it can be the second argument.
  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]) || undefined

  chrome.sockets.tcpServer.create(function (createInfo) {
    self.id = createInfo.socketId

    chrome.sockets.tcpServer.listen(self.id, address, port, backlog, function (result) {
      if (result < 0) {
        self.emit('error', new Error('Socket ' + self.id + ' failed to listen. ' +
          chrome.runtime.lastError.message))
        self._destroy()
        return
      }

      self._address = address
      self._port = port

      servers[self.id] = self
      self.emit('listening')
    })
  })

  return self
}

Server.prototype._onAccept = function (clientSocketId) {
  var self = this

  // Set the `maxConnections` property to reject connections when the server's
  // connection count gets high.
  if (self.maxConnections && self._connections >= self.maxConnections) {
    chrome.sockets.tcpServer.disconnect(clientSocketId)
    chrome.sockets.tcpServer.close(clientSocketId)
    console.warn('Rejected connection - hit `maxConnections` limit')
    return
  }

  self._connections += 1

  var acceptedSocket = new Socket({
    server: self,
    id: clientSocketId
  })
  acceptedSocket.on('connect', function () {
    self.emit('connection', acceptedSocket)
  })

  chrome.sockets.tcp.setPaused(clientSocketId, false)
}

Server.prototype._onAcceptError = function (resultCode) {
  var self = this
  self.emit('error', new Error('Socket ' + self.id + ' failed to accept (' +
    resultCode + ')'))
  self._destroy()
}

/**
 * Stops the server from accepting new connections and keeps existing
 * connections. This function is asynchronous, the server is finally closed
 * when all connections are ended and the server emits a 'close' event.
 * Optionally, you can pass a callback to listen for the 'close' event.
 * @param  {function} callback
 */
Server.prototype.close = function (callback) {
  var self = this
  self._destroy(callback)
}

Server.prototype._destroy = function (exception, cb) {
  var self = this

  if (self._destroyed)
    return

  if (cb)
    this.once('close', cb)

  this._destroyed = true
  this._connections = 0
  delete servers[self.id]

  chrome.sockets.tcpServer.disconnect(self.id, function () {
    chrome.sockets.tcpServer.close(self.id, function () {
      self.emit('close')
    })
  })
}

/**
 * Returns the bound address, the address family name and port of the socket
 * as reported by the operating system. Returns an object with three
 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
 *
 * @return {Object} information
 */
Server.prototype.address = function () {
  var self = this
  return {
    address: self._address,
    port: self._port,
    family: 'IPv4'
  }
}

Server.prototype.unref = function () {
  // No chrome.socket equivalent
}

Server.prototype.ref = function () {
  // No chrome.socket equivalent
}

/**
 * Asynchronously get the number of concurrent connections on the server.
 * Works when sockets were sent to forks.
 *
 * Callback should take two arguments err and count.
 *
 * @param  {function} callback
 */
Server.prototype.getConnections = function (callback) {
  var self = this
  process.nextTick(function () {
    callback(null, self._connections)
  })
}


inherits(Socket, stream.Duplex)

/**
 * Class: net.Socket
 * =================
 *
 * This object is an abstraction of a TCP or UNIX socket. net.Socket instances
 * implement a duplex Stream interface. They can be created by the user and
 * used as a client (with connect()) or they can be created by Node and passed
 * to the user through the 'connection' event of a server.
 *
 * Construct a new socket object.
 *
 * options is an object with the following defaults:
 *
 *   { fd: null // NO CHROME EQUIVALENT
 *     type: null
 *     allowHalfOpen: false // NO CHROME EQUIVALENT
 *   }
 *
 * `type` can only be 'tcp4' (for now).
 *
 * Event: 'connect'
 *   Emitted when a socket connection is successfully established. See
 *   connect().
 *
 * Event: 'data'
 *   - Buffer object
 *   Emitted when data is received. The argument data will be a Buffer or
 *   String. Encoding of data is set by socket.setEncoding(). (See the Readable
 *   Stream section for more information.)
 *
 *   Note that the data will be lost if there is no listener when a Socket
 *   emits a 'data' event.
 *
 * Event: 'end'
 *   Emitted when the other end of the socket sends a FIN packet.
 *
 *   By default (allowHalfOpen == false) the socket will destroy its file
 *   descriptor once it has written out its pending write queue. However,
 *   by setting allowHalfOpen == true the socket will not automatically
 *   end() its side allowing the user to write arbitrary amounts of data,
 *   with the caveat that the user is required to end() their side now.
 *
 * Event: 'timeout'
 *   Emitted if the socket times out from inactivity. This is only to notify
 *   that the socket has been idle. The user must manually close the connection.
 *
 *   See also: socket.setTimeout()
 *
 * Event: 'drain'
 *   Emitted when the write buffer becomes empty. Can be used to throttle
 *   uploads.
 *
 *   See also: the return values of socket.write()
 *
 * Event: 'error'
 *   - Error object
 *   Emitted when an error occurs. The 'close' event will be called directly
 *   following this event.
 *
 * Event: 'close'
 *   - had_error Boolean true if the socket had a transmission error
 *   Emitted once the socket is fully closed. The argument had_error is a
 *   boolean which says if the socket was closed due to a transmission error.
 */
function Socket (options) {
  var self = this
  if (!(self instanceof Socket)) return new Socket(options)

  if (is.isUndefined(options))
    options = {}

  stream.Duplex.call(self, options)

  self.destroyed = false
  self.errorEmitted = false
  self.readable = self.writable = false

  // The amount of received bytes.
  self.bytesRead = 0

  self._bytesDispatched = 0
  self._connecting = false

  if (options.server) {
    self.server = options.server
    self.id = options.id

    // For incoming sockets (from server), it's already connected.
    self._connecting = true
    self._onConnect()
  }
}

/**
 * socket.connect(port, [host], [connectListener])
 * socket.connect(options, [connectListener])
 *
 * Opens the connection for a given socket. If port and host are given, then
 * the socket will be opened as a TCP socket, if host is omitted, localhost
 * will be assumed. If a path is given, the socket will be opened as a unix
 * socket to that path.
 *
 * Normally this method is not needed, as net.createConnection opens the
 * socket. Use this only if you are implementing a custom Socket.
 *
 * This function is asynchronous. When the 'connect' event is emitted the
 * socket is established. If there is a problem connecting, the 'connect'
 * event will not be emitted, the 'error' event will be emitted with the
 * exception.
 *
 * The connectListener parameter will be added as an listener for the
 * 'connect' event.
 *
 * @param  {Object} options
 * @param  {function} [connectListener]
 * @return {Socket}   this socket (for chaining)
 */
Socket.prototype.connect = function (options, cb) {
  var self = this

  if (self._connecting)
    return
  self._connecting = true

  var port = Number(options.port)

  if (is.isFunction(cb)) {
    self.once('connect', cb)
  }

  chrome.sockets.tcp.create(function (createInfo) {
    self.id = createInfo.socketId

    chrome.sockets.tcp.connect(self.id, options.host, port, function (result) {
      if (result < 0) {
        self.destroy(new Error('Socket ' + self.id + ' connect error ' + result))
        return
      }

      self._onConnect()
    })
  })

  return self
}

Socket.prototype._onConnect = function () {
  var self = this

  sockets[self.id] = self
  chrome.sockets.tcp.getInfo(self.id, function (result) {
    self.remoteAddress = result.peerAddress
    self.remotePort = result.peerPort
    self.localAddress = result.localAddress
    self.localPort = result.localPort

    self._connecting = false
    self.readable = self.writable = true

    self.emit('connect')
    // start the first read, or get an immediate EOF.
    // this doesn't actually consume any bytes, because len=0
    self.read(0)
  })
}

/**
 * The number of characters currently buffered to be written.
 * @type {number}
 */
Object.defineProperty(Socket.prototype, 'bufferSize', {
  get: function () {
    var self = this
    if (self._pendingData)
      return self._pendingData.length
    else
      return 0 // Unfortunately, chrome.socket does not make this info available
  }
})

/**
 * Sends data on the socket. The second parameter specifies the encoding in
 * the case of a string--it defaults to UTF8 encoding.
 *
 * Returns true if the entire data was flushed successfully to the kernel
 * buffer. Returns false if all or part of the data was queued in user memory.
 * 'drain' will be emitted when the buffer is again free.
 *
 * The optional callback parameter will be executed when the data is finally
 * written out - this may not be immediately.
 *
 * @param  {Buffer|Arrayish|string} chunk
 * @param  {string} [encoding]
 * @param  {function} [callback]
 * @return {boolean}             flushed to kernel completely?
 */
Socket.prototype.write = function (chunk, encoding, callback) {
  var self = this
  if (!Buffer.isBuffer(chunk))
    chunk = new Buffer(chunk, encoding)

  return stream.Duplex.prototype.write.call(self, chunk, encoding, callback)
}

Socket.prototype._write = function (buffer, encoding, callback) {
  var self = this
  if (!callback) callback = function () {}

  if (!self.writable) {
    self._pendingData = buffer
    self._pendingEncoding = encoding
    self.once('connect', function () {
      self._write(buffer, encoding, callback)
    })
    return
  }
  self._pendingData = null
  self._pendingEncoding = null

  // assuming buffer is browser implementation (`buffer` package on npm)
  chrome.sockets.tcp.send(self.id, buffer.buffer /* buffer.toArrayBuffer() is slower */,
                          function (sendInfo) {
    if (sendInfo.resultCode < 0) {
      var err = new Error('Socket ' + self.id + ' write error: ' + sendInfo.resultCode)
      callback(err)
      self.destroy(err)
    } else {
      self._resetTimeout()
      callback(null)
    }
  })

  self._bytesDispatched += buffer.length
}

Socket.prototype._read = function (bufferSize) {
  var self = this
  if (self._connecting) {
    self.once('connect', self._read.bind(self, bufferSize))
    return
  }

  chrome.sockets.tcp.setPaused(self.id, false)
}

Socket.prototype._onReceive = function (data) {
  var self = this
  var buffer = new Buffer(new Uint8Array(data))

  self.bytesRead += buffer.length
  self._resetTimeout()

  if (!self.push(buffer)) { // if returns false, then apply backpressure
    chrome.sockets.tcp.setPaused(self.id, true)
  }
}

Socket.prototype._onReceiveError = function (resultCode) {
  var self = this
  if (resultCode === -100) {
    self.push(null)
    self.destroy()
  } else if (resultCode < 0) {
    self.destroy(new Error('Socket ' + self.id + ' receive error ' + resultCode))
  }
}

/**
 * The amount of bytes sent.
 * @return {number}
 */
Object.defineProperty(Socket.prototype, 'bytesWritten', {
  get: function () {
    var self = this
    var bytes = self._bytesDispatched

    self._writableState.toArrayBuffer().forEach(function (el) {
      if (Buffer.isBuffer(el.chunk))
        bytes += el.chunk.length
      else
        bytes += new Buffer(el.chunk, el.encoding).length
    })

    if (self._pendingData) {
      if (Buffer.isBuffer(self._pendingData))
        bytes += self._pendingData.length
      else
        bytes += Buffer.byteLength(self._pendingData, self._pendingEncoding)
    }

    return bytes
  }
})

Socket.prototype.destroy = function (exception) {
  var self = this
  self._destroy(exception)
}

Socket.prototype._destroy = function (exception, cb) {
  var self = this

  function fireErrorCallbacks () {
    if (cb) cb(exception)
    if (exception && !self.errorEmitted) {
      process.nextTick(function () {
        self.emit('error', exception)
      })
      self.errorEmitted = true
    }
  }

  if (self.destroyed) {
    // already destroyed, fire error callbacks
    fireErrorCallbacks()
    return
  }

  if (this.server) {
    this.server._connections -= 1
  }

  self._connecting = false
  this.readable = this.writable = false
  self.destroyed = true
  delete sockets[self.id]

  chrome.sockets.tcp.disconnect(self.id, function () {
    chrome.sockets.tcp.close(self.id, function () {
      self.emit('close', !!exception)
      fireErrorCallbacks()
    })
  })
}

/**
 * Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
 * By default net.Socket do not have a timeout. When an idle timeout is triggered the
 * socket will receive a 'timeout' event but the connection will not be severed. The
 * user must manually end() or destroy() the socket.
 *
 * If timeout is 0, then the existing idle timeout is disabled.
 *
 * The optional callback parameter will be added as a one time listener for the 'timeout' event.
 *
 * @param {number}   timeout
 * @param {function} callback
 */
Socket.prototype.setTimeout = function (timeout, callback) {
  var self = this
  if (callback) self.once('timeout', callback)
  self._timeoutMs = timeout
  self._resetTimeout()
}

Socket.prototype._onTimeout = function () {
  var self = this
  self._timeout = null
  self._timeoutMs = 0
  self.emit('timeout')
}

Socket.prototype._resetTimeout = function () {
  var self = this
  if (self._timeout) {
    clearTimeout(self._timeout)
  }
  if (self._timeoutMs) {
    self._timeout = setTimeout(self._onTimeout, self.timeoutMs)
  }
}

/**
 * Disables the Nagle algorithm. By default TCP connections use the Nagle
 * algorithm, they buffer data before sending it off. Setting true for noDelay
 * will immediately fire off data each time socket.write() is called. noDelay
 * defaults to true.
 *
 * NOTE: The Chrome version of this function is async, whereas the node
 * version is sync. Keep this in mind.
 *
 * @param {boolean} [noDelay] Optional
 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
 *                            operation is done.
 */
Socket.prototype.setNoDelay = function (noDelay, callback) {
  var self = this
  // backwards compatibility: assume true when `enable` is omitted
  noDelay = is.isUndefined(noDelay) ? true : !!noDelay
  if (!callback) callback = function () {}
  chrome.sockets.tcp.setNoDelay(self.id, noDelay, callback)
}

/**
 * Enable/disable keep-alive functionality, and optionally set the initial
 * delay before the first keepalive probe is sent on an idle socket. enable
 * defaults to false.
 *
 * Set initialDelay (in milliseconds) to set the delay between the last data
 * packet received and the first keepalive probe. Setting 0 for initialDelay
 * will leave the value unchanged from the default (or previous) setting.
 * Defaults to 0.
 *
 * NOTE: The Chrome version of this function is async, whereas the node
 * version is sync. Keep this in mind.
 *
 * @param {boolean} [enable] Optional
 * @param {number} [initialDelay]
 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
 *                            operation is done.
 */
Socket.prototype.setKeepAlive = function (enable, initialDelay, callback) {
  var self = this
  if (!callback) callback = function () {}
  chrome.sockets.tcp.setKeepAlive(self.id, !!enable, ~~(initialDelay / 1000),
      callback)
}

/**
 * Returns the bound address, the address family name and port of the socket
 * as reported by the operating system. Returns an object with three
 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
 *
 * @return {Object} information
 */
Socket.prototype.address = function () {
  var self = this
  return {
    address: self.localAddress,
    port: self.localPort,
    family: 'IPv4'
  }
}

Object.defineProperty(Socket.prototype, 'readyState', {
  get: function () {
    var self = this
    if (self._connecting) {
      return 'opening'
    } else if (self.readable && self.writable) {
      return 'open'
    } else {
      return 'closed'
    }
  }
})

Socket.prototype.unref = function () {
  // No chrome.socket equivalent
}

Socket.prototype.ref = function () {
  // No chrome.socket equivalent
}

//
// EXPORTED HELPERS
//

exports.isIP = function (input) {
  try {
    ipaddr.parse(input)
  } catch (e) {
    return false
  }
  return true
}

exports.isIPv4 = function (input) {
  try {
    var parsed = ipaddr.parse(input)
    return (parsed.kind() === 'ipv4')
  } catch (e) {
    return false
  }
}

exports.isIPv6 = function (input) {
  try {
    var parsed = ipaddr.parse(input)
    return (parsed.kind() === 'ipv6')
  } catch (e) {
    return false
  }
}

//
// HELPERS
//

/**
 * Returns an array [options] or [options, cb]
 * It is the same as the argument of Socket.prototype.connect().
 */
function normalizeConnectArgs (args) {
  var options = {}

  if (is.isObject(args[0])) {
    // connect(options, [cb])
    options = args[0]
  } else {
    // connect(port, [host], [cb])
    options.port = args[0]
    if (is.isString(args[1])) {
      options.host = args[1]
    } else {
      options.host = '127.0.0.1'
    }
  }

  var cb = args[args.length - 1]
  return is.isFunction(cb) ? [options, cb] : [options]
}

function toNumber (x) {
  return (x = Number(x)) >= 0 ? x : false
}
